// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// i2s_sck //
// ------- //

#define i2s_sck_wrap_target 0
#define i2s_sck_wrap 1

static const uint16_t i2s_sck_program_instructions[] = {
            //     .wrap_target
    0xe001, //  0: set    pins, 1                    
    0xe000, //  1: set    pins, 0                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2s_sck_program = {
    .instructions = i2s_sck_program_instructions,
    .length = 2,
    .origin = -1,
};

static inline pio_sm_config i2s_sck_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2s_sck_wrap_target, offset + i2s_sck_wrap);
    return c;
}
#endif

// -------------- //
// i2s_out_master //
// -------------- //

#define i2s_out_master_wrap_target 0
#define i2s_out_master_wrap 7

#define i2s_out_master_offset_entry_point 0u

static const uint16_t i2s_out_master_program_instructions[] = {
            //     .wrap_target
    0xe03e, //  0: set    x, 30           side 0     
    0x8880, //  1: pull   noblock         side 1     
    0x6001, //  2: out    pins, 1         side 0     
    0x0842, //  3: jmp    x--, 2          side 1     
    0xf03e, //  4: set    x, 30           side 2     
    0x9880, //  5: pull   noblock         side 3     
    0x7001, //  6: out    pins, 1         side 2     
    0x1846, //  7: jmp    x--, 6          side 3     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2s_out_master_program = {
    .instructions = i2s_out_master_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config i2s_out_master_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2s_out_master_wrap_target, offset + i2s_out_master_wrap);
    sm_config_set_sideset(&c, 2, false, false);
    return c;
}
#endif

// -------------- //
// i2s_bidi_slave //
// -------------- //

#define i2s_bidi_slave_wrap_target 0
#define i2s_bidi_slave_wrap 23

static const uint16_t i2s_bidi_slave_program_instructions[] = {
            //     .wrap_target
    0x20a1, //  0: wait   1 pin, 1                   
    0x4001, //  1: in     pins, 1                    
    0x8080, //  2: pull   noblock                    
    0x8000, //  3: push   noblock                    
    0x2021, //  4: wait   0 pin, 1                   
    0x2022, //  5: wait   0 pin, 2                   
    0x6001, //  6: out    pins, 1                    
    0x20a1, //  7: wait   1 pin, 1                   
    0x4001, //  8: in     pins, 1                    
    0x2021, //  9: wait   0 pin, 1                   
    0x6001, // 10: out    pins, 1                    
    0x00cd, // 11: jmp    pin, 13                    
    0x0007, // 12: jmp    7                          
    0x20a1, // 13: wait   1 pin, 1                   
    0x4001, // 14: in     pins, 1                    
    0x8080, // 15: pull   noblock                    
    0x8000, // 16: push   noblock                    
    0x2021, // 17: wait   0 pin, 1                   
    0x6001, // 18: out    pins, 1                    
    0x20a1, // 19: wait   1 pin, 1                   
    0x4001, // 20: in     pins, 1                    
    0x2021, // 21: wait   0 pin, 1                   
    0x6001, // 22: out    pins, 1                    
    0x00d3, // 23: jmp    pin, 19                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2s_bidi_slave_program = {
    .instructions = i2s_bidi_slave_program_instructions,
    .length = 24,
    .origin = -1,
};

static inline pio_sm_config i2s_bidi_slave_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2s_bidi_slave_wrap_target, offset + i2s_bidi_slave_wrap);
    return c;
}
#endif

// ------------ //
// i2s_in_slave //
// ------------ //

#define i2s_in_slave_wrap_target 0
#define i2s_in_slave_wrap 17

static const uint16_t i2s_in_slave_program_instructions[] = {
            //     .wrap_target
    0x20a1, //  0: wait   1 pin, 1                   
    0x4001, //  1: in     pins, 1                    
    0x8000, //  2: push   noblock                    
    0x2021, //  3: wait   0 pin, 1                   
    0x2022, //  4: wait   0 pin, 2                   
    0x20a1, //  5: wait   1 pin, 1                   
    0x4001, //  6: in     pins, 1                    
    0x2021, //  7: wait   0 pin, 1                   
    0x00ca, //  8: jmp    pin, 10                    
    0x0005, //  9: jmp    5                          
    0x20a1, // 10: wait   1 pin, 1                   
    0x4001, // 11: in     pins, 1                    
    0x8000, // 12: push   noblock                    
    0x2021, // 13: wait   0 pin, 1                   
    0x20a1, // 14: wait   1 pin, 1                   
    0x4001, // 15: in     pins, 1                    
    0x2021, // 16: wait   0 pin, 1                   
    0x00ce, // 17: jmp    pin, 14                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program i2s_in_slave_program = {
    .instructions = i2s_in_slave_program_instructions,
    .length = 18,
    .origin = -1,
};

static inline pio_sm_config i2s_in_slave_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + i2s_in_slave_wrap_target, offset + i2s_in_slave_wrap);
    return c;
}

// These constants are the I2S clock to pio clock ratio
const int i2s_sck_program_pio_mult = 2;
const int i2s_out_master_program_pio_mult = 2;
/*
 * System ClocK (SCK) is only required by some I2S peripherals.
 * This outputs it at 1 SCK per 2 PIO clocks, so scale the dividers correctly
 * first.
 * NOTE: Most peripherals require that this is *perfectly* aligned in ratio,
 *       if not phase, to the bit and word clocks of any master peripherals.
 *       It is up to you to ensure that the divider config is set up for a
 *       precise (not approximate) ratio between the BCK, LRCK, and SCK outputs.
 */
static void i2s_sck_program_init(PIO pio, uint8_t sm, uint8_t offset, uint8_t sck_pin) {
    pio_gpio_init(pio, sck_pin);
    pio_sm_config sm_config = i2s_sck_program_get_default_config(offset);
    sm_config_set_set_pins(&sm_config, sck_pin, 1);
    uint pin_mask = (1u << sck_pin);
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask);  // zero output
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);
    pio_sm_init(pio, sm, offset, &sm_config);
}
static inline void i2s_out_master_program_init(PIO pio, uint8_t sm, uint8_t offset, uint8_t bit_depth, uint8_t dout_pin, uint8_t clock_pin_base) {
    pio_gpio_init(pio, dout_pin);
    pio_gpio_init(pio, clock_pin_base);
    pio_gpio_init(pio, clock_pin_base + 1);
    pio_sm_config sm_config = i2s_out_master_program_get_default_config(offset);
    sm_config_set_out_pins(&sm_config, dout_pin, 1);
    sm_config_set_sideset_pins(&sm_config, clock_pin_base);
    sm_config_set_out_shift(&sm_config, false, false, bit_depth);
    sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_TX);
    pio_sm_init(pio, sm, offset, &sm_config);
    uint32_t pin_mask = (1u << dout_pin) | (3u << clock_pin_base);
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask);  // zero output
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);
}
static inline void i2s_bidi_slave_program_init(PIO pio, uint8_t sm, uint8_t offset, uint8_t dout_pin, uint8_t in_pin_base) {
    pio_gpio_init(pio, dout_pin);
    pio_gpio_init(pio, in_pin_base);
    pio_gpio_init(pio, in_pin_base + 1);
    pio_gpio_init(pio, in_pin_base + 2);
    pio_sm_config sm_config = i2s_bidi_slave_program_get_default_config(offset);
    sm_config_set_out_pins(&sm_config, dout_pin, 1);
    sm_config_set_in_pins(&sm_config, in_pin_base);
    sm_config_set_jmp_pin(&sm_config, in_pin_base + 2);
    sm_config_set_out_shift(&sm_config, false, false, 0);
    sm_config_set_in_shift(&sm_config, false, false, 0);
    pio_sm_init(pio, sm, offset, &sm_config);
    // Setup output pins
    uint32_t pin_mask = (1u << dout_pin);
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask);  // zero output
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);
    // Setup input pins
    pin_mask = (7u << in_pin_base);  // Three input pins
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);
}
/*
 *  Designed to be used with output master module, requiring overlapping pins:
 *    din_pin_base + 0 = input pin
 *    din_pin_base + 1 = out_master clock_pin_base
 *    din_pin_base + 2 = out_master clock_pin_base + 1
 *
 *  Intended to be run at SCK rate (4x BCK), so clock same as SCK module if using
 *  it, or 4x the BCK frequency (BCK is 64x fs, so 256x fs).
 */
static inline void i2s_in_slave_program_init(PIO pio, uint8_t sm, uint8_t offset, uint8_t din_pin_base) {
    pio_gpio_init(pio, din_pin_base);
    gpio_set_pulls(din_pin_base, false, false);
    gpio_set_dir(din_pin_base, GPIO_IN);
    pio_sm_config sm_config = i2s_in_slave_program_get_default_config(offset);
    sm_config_set_in_pins(&sm_config, din_pin_base);
    sm_config_set_in_shift(&sm_config, false, false, 0);
    sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_RX);
    sm_config_set_jmp_pin(&sm_config, din_pin_base + 2);
    pio_sm_init(pio, sm, offset, &sm_config);
    uint32_t pin_mask = (7u << din_pin_base);  // Three input pins
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);
}

#endif
